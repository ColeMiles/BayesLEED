Main To-do
==============

- Get access to the group's cluster
- Get "warm start" working
    - Everything relevant in TLEED/LaNiO3_example/
    - Goal: Get a simple Bayesian optimization loop which can replicate
              the final results of run.search.
            The general overview for doing this is that a Python script
              will be running botorch to model the Bayesian optimization
              loop, which produces atomic displacements which are written
              out to whatever data file. run.ref-calc then will compute
              the full dynamic LEED calculation, and the quality of the fit
              is ascertained by run.r-factor. The returned R-factor is the
              thing to minimize here.
    - Necessary: Ask Jordan for his Python scripts
- Python FFI interface please
    1) refcalc


Misc. Notes
===============

- To compile anything to a shared library, the file TLEED/v1.2/src/GLOBAL
   must be present
- Library compilation command: `gfortran -g -shared -fPIC -o <libname>.so <libname>.f`
- `nm -l` is the command to extract symbols from shared library
- Coordinate order in TLEED files is (z, x, y)...
- The TLEED code is searching over the search space of displacements between
    -0.2 and 0.2, I should do the same (but normalize to unit cube in search space)

TLEED Library Structure
=======================
TLEED/
    aux/
    beamlists/
    exp-data/
    LaNiO3_example/
        run.*
    phaseshifts/
    testrun/
    v1.2/
        lib/
            lib.*.f
        src/
            *.f 

How the pipeline for refcalc works:
run.ref-calc does:
    1) Writes a bit of extra Fortran into a file called "PARAM" which I believe specifies
        the dimensions of some of the tensors or something?
    2) Writes a whole input set of parameters to a file called "FIN". Inside this:
        - Some general calculation parameters: how many beams to use/blah blah
        - beamlist generated by run.beamgen
        - phaseshifts located in phaseshifts/
        - defining the atomic structure
    3) Creates a Fortran file muftin.f which defines the atomic potential functional form
    4) Compiles everything (these files INCLUDE the PARAM file previously generated!)
    5) Runs the compiled executable, providing FIN through stdin
    6) Cleans up


Python Bindings
===============
Possibilities:
1) No bindings. The Python pipeline simply edits FIN on each new execution.
2) f2py
3) ctypes

First attempt: f2py
Keeping in mind the above pipeline, the idea for these bindings is as follows:
    1) Write a 
